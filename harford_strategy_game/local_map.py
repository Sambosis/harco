"""
local_map.py

Concrete map definition and utilities for *Harford County Clash*.

This module is intentionally lightweight—it does **not** deal with external
asset loading (handled by ``map_data.py`` elsewhere).  Instead, it hard-codes a
10 × 10 landmark grid and offers a :class:`MapFactory` with convenience helpers
for:

• Producing a fully-initialised :class:`game_state.GameState` that contains:
    – A :class:`game_state.Tile` object for **every** board position.
    – Team headquarters for *BlueCrabs* (Bel Air) and *BayBirds*
      (Havre de Grace).
    – Three starter :class:`game_state.Unit` objects per team deployed on
      walkable tiles adjacent to their respective HQ.

• Translating simple compass directions (``"N"``, ``"SW"``, …) into `(dx, dy)`
  offsets—used by movement validation elsewhere in the code-base.

All coordinates follow the standard **screen / array orientation**:

    (0, 0) ──►  x   (increases to the right)
      │
      ▼  y   (increases downward)

Author
------
Auto-generated by OpenAI ChatGPT
"""

from __future__ import annotations

import itertools
from typing import Dict, List, Tuple

# --------------------------------------------------------------------------- #
# Internal Imports                                                            #
# --------------------------------------------------------------------------- #

from game_state import Coord, GameState, Tile, Unit

# --------------------------------------------------------------------------- #
# Public Constants                                                            #
# --------------------------------------------------------------------------- #

GRID_WIDTH: int = 10
GRID_HEIGHT: int = 10

# Human-readable landmarks—row-major order.
# fmt: off
LANDMARK_GRID: Tuple[Tuple[str, ...], ...] = (
    (
        "Dublin", "Pylesville", "Whiteford", "Cardiff", "Street",
        "Forest Hill", "Jarrettsville", "Madonna", "Upper Crossroads", "Fallston",
    ),
    (
        "Darlington", "Level", "Street", "Forest Hill", "Bel Air North",
        "Bel Air", "Hickory", "Troy", "Bynum", "Kingsville",
    ),
    (
        "Havre de Grace", "Lapidum", "Churchville", "Aberdeen Proving Ground",
        "Belcamp", "Riverside", "Abingdon", "Edgewood", "Joppatowne", "Gunpowder",
    ),
    (
        "Perryman", "Charlestown", "Perryville", "Port Deposit", "Oakington",
        "Hopewell", "Emmorton", "Otter Point", "Magnolia", "White Marsh",
    ),
    tuple(f"Row4-Col{i}" for i in range(GRID_WIDTH)),
    tuple(f"Row5-Col{i}" for i in range(GRID_WIDTH)),
    tuple(f"Row6-Col{i}" for i in range(GRID_WIDTH)),
    tuple(f"Row7-Col{i}" for i in range(GRID_WIDTH)),
    tuple(f"Row8-Col{i}" for i in range(GRID_WIDTH)),
    tuple(f"Row9-Col{i}" for i in range(GRID_WIDTH)),
)
# fmt: on

# --------------------------------------------------------------------------- #
# Helper Data                                                                 #
# --------------------------------------------------------------------------- #

_DIRECTION_DELTAS: Dict[str, Tuple[int, int]] = {
    "N": (0, -1),
    "NE": (1, -1),
    "E": (1, 0),
    "SE": (1, 1),
    "S": (0, 1),
    "SW": (-1, 1),
    "W": (-1, 0),
    "NW": (-1, -1),
}


# --------------------------------------------------------------------------- #
# MapFactory                                                                  #
# --------------------------------------------------------------------------- #


class MapFactory:
    """
    Build starting :class:`game_state.GameState` objects and provide misc.
    grid helpers.  Nothing in this class mutates global state—safe to call
    multiple times in tests.
    """

    # Expose for external modules (e.g. viewers, engines).
    GRID_WIDTH: int = GRID_WIDTH
    GRID_HEIGHT: int = GRID_HEIGHT

    # HQ positions (x, y)
    BLUECRABS_HQ: Tuple[int, int] = (4, 5)  # Bel Air
    BAYBIRDS_HQ: Tuple[int, int] = (8, 2)   # Havre de Grace

    STARTING_UNITS_PER_TEAM: int = 3

    # --------------------------------------------------------------------- #
    # Public Construction                                                   #
    # --------------------------------------------------------------------- #

    @classmethod
    def build_initial_state(cls) -> GameState:
        """
        Create a canonical `GameState` with both factions in their default
        starting locations.

        Returns
        -------
        GameState
            An immutable *snapshot* of the board at turn 0.
        """

        # 1. Build the full tile list.
        tiles: List[Tile] = []
        for y in range(GRID_HEIGHT):
            for x in range(GRID_WIDTH):
                landmark_name: str = LANDMARK_GRID[y][x]
                terrain_type: str = _infer_terrain_from_landmark(landmark_name)
                traversable: bool = terrain_type != "water"
                tiles.append(
                    Tile(
                        coord=Coord(x, y),
                        name=landmark_name,
                        terrain_type=terrain_type,
                        traversable=traversable,
                    )
                )

        # 2. Headquarters mapping.
        team_hqs: Dict[str, Coord] = {
            "BlueCrabs": Coord(*cls.BLUECRABS_HQ),
            "BayBirds": Coord(*cls.BAYBIRDS_HQ),
        }

        # 3. Spawn starting units.
        units: Dict[str, Unit] = {}
        units.update(
            _spawn_initial_team_units(
                team_id="BlueCrabs",
                hq_coord=team_hqs["BlueCrabs"],
                count=cls.STARTING_UNITS_PER_TEAM,
            )
        )
        units.update(
            _spawn_initial_team_units(
                team_id="BayBirds",
                hq_coord=team_hqs["BayBirds"],
                count=cls.STARTING_UNITS_PER_TEAM,
            )
        )

        # 4. Assemble GameState (using defaults for turn counter, etc.).
        return GameState(
            tiles=tiles,
            units=units,
            team_hqs=team_hqs,
        )

    # ------------------------------------------------------------------ #
    # Utility Functions                                                  #
    # ------------------------------------------------------------------ #

    @staticmethod
    def direction_to_delta(direction: str) -> Tuple[int, int]:
        """
        Safely convert a compass string to an (x, y) delta.

        The lookup is **case-insensitive** and trims leading / trailing
        whitespace for leniency.

        Raises
        ------
        ValueError
            If *direction* is not one of the recognised keys.
        """
        if not isinstance(direction, str):
            raise ValueError("direction must be a string")

        key: str = direction.strip().upper()
        try:
            return _DIRECTION_DELTAS[key]
        except KeyError as exc:  # pragma: no cover – explicit branch for clarity
            valid = ", ".join(_DIRECTION_DELTAS.keys())
            raise ValueError(f"Unsupported direction '{direction}'. Must be one of: {valid}") from exc


# --------------------------------------------------------------------------- #
# Internal Helper Functions (module-private)                                  #
# --------------------------------------------------------------------------- #


def _infer_terrain_from_landmark(name: str) -> str:
    """
    Very small heuristic to tag obvious water / urban landmarks.
    Anything not recognised defaults to "rural".

    This *does not* aim for geographical accuracy; it simply gives different
    terrain strings to make the printed board more interesting.
    """
    lowered = name.lower()
    if any(w in lowered for w in ("river", "gunpowder", "bay", "point", "harbor", "havre")):
        return "water"
    if any(c in lowered for c in ("bel air", "aberdeen", "edgewood", "joppatowne", "town", "white marsh")):
        return "urban"
    return "rural"


def _spawn_initial_team_units(
    *,
    team_id: str,
    hq_coord: Coord,
    count: int,
) -> Dict[str, Unit]:
    """
    Place *count* units in walkable, in-bounds tiles adjacent to *hq_coord*.
    The algorithm iterates neighbours in a deterministic clockwise order
    (N, NE, E, SE, S, SW, W, NW) until `count` valid positions are found.

    Duplicate / out-of-bounds positions are silently skipped.  This ensures
    the function never raises under normal 10 × 10 constraints.
    """
    units: Dict[str, Unit] = {}
    neighbour_deltas: Tuple[Tuple[int, int], ...] = (
        (0, -1),  # N
        (1, -1),  # NE
        (1, 0),   # E
        (1, 1),   # SE
        (0, 1),   # S
        (-1, 1),  # SW
        (-1, 0),  # W
        (-1, -1),  # NW
    )

    generated: int = 0
    unit_idx_iter = itertools.count(1)  # 1, 2, 3, …

    for dx, dy in neighbour_deltas:
        if generated >= count:
            break

        nx, ny = hq_coord.x + dx, hq_coord.y + dy
        if not (0 <= nx < GRID_WIDTH and 0 <= ny < GRID_HEIGHT):
            continue  # off-board

        pos = Coord(nx, ny)
        unit_id = f"{team_id}-{next(unit_idx_iter)}"
        units[unit_id] = Unit(
            id=unit_id,
            team_id=team_id,
            coord=pos,
            hp=10,
            attack_power=5,
        )
        generated += 1

    # Fallback guard: If the HQ is near an edge and we couldn't place enough
    # units, pad the remainder *on top* of the HQ (allowed – HQ tile is
    # traversable).  This guarantees the requested count is always satisfied.
    while generated < count:
        unit_id = f"{team_id}-{next(unit_idx_iter)}"
        units[unit_id] = Unit(
            id=unit_id,
            team_id=team_id,
            coord=hq_coord,
            hp=10,
            attack_power=5,
        )
        generated += 1

    return units